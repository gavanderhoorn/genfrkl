@####################################################
@#
@# ROS service source code generation for Fanuc Karel
@#
@# EmPy template for generating <srv>.kl files
@#
@####################################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .srv file
@#  - md5sum (String) MD5Sum of the .srv specification
@#
@####################################################
-- Copyright 2015 TU Delft Robotics Institute
-- 
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
-- 
--     http://www.apache.org/licenses/LICENSE-2.0
-- 
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
@{
import genmsg.msgs
import genfrkl
import genfrkl.utils

import textwrap


sm_id_data = genfrkl.load_id_mapper_file('sm_assigned_ids.yaml')

mapped_msg_type = sm_id_data[md5sum]             # 10
msg_id_hex      = '%04X'      % mapped_msg_type  # '000A'
kl_smname       = 'sm%04X'    % mapped_msg_type  # 'sm000A'
kl_structname   = 'sm%04X_t'  % mapped_msg_type  # 'sm000A_t'
kl_libname      = 'libsm%04X' % mapped_msg_type  # 'libsm000A'

# global settings
LINE_WIDTH = 72
}@


PROGRAM @(kl_libname)
--------------------------------------------------------------------------------
-- 
-- @(spec.package)/@(spec.short_name) (@(kl_libname)) library implementation.
-- 
-- Autogenerated by genmsg_frkl from @file_name_in
-- 
-- MD5 of source ROS msg: @md5sum
-- 
-- author: G.A. vd. Hoorn (TU Delft Robotics Institute)
-- 
--------------------------------------------------------------------------------
%ALPHABETIZE
%COMMENT = 'ROS//r0  @md5sum[:6]'
%NOBUSYLAMP
%NOLOCKGROUP
%NOPAUSE = COMMAND + TPENABLE + ERROR




--------------------------------------------------------------------------------
-- 
-- remote types & constants
-- 
--------------------------------------------------------------------------------
%INCLUDE include\ktype_sz.th
@{
# avoid generating duplicate include statements
all_fields = spec.request.parsed_fields() + spec.response.parsed_fields()

# we only care about field types here
for field in genfrkl.utils.uniqify(all_fields, lambda x: x.type):
  if not genfrkl.is_primitive_kl_type(field.type):
    base_name = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)
    print "%%INCLUDE include\lib%s.th" % base_name
}@




--------------------------------------------------------------------------------
-- 
-- local types & constants
-- 
--------------------------------------------------------------------------------
%INCLUDE include\@(kl_libname).th

CONST
    -- internal use only
    @(kl_smname.upper())_PID_  = @(kl_smname.upper())_ID
    @(kl_smname.upper())_STR_  = '@(spec.short_name)'
    @(kl_smname.upper())Q_STR_ = '@(spec.short_name)_Request'
    @(kl_smname.upper())Q_LEN_ = @('%d' % genfrkl.calculate_msg_length(spec.request))
    @(kl_smname.upper())R_STR_ = '@(spec.short_name)_Response'
    @(kl_smname.upper())R_LEN_ = @('%d' % genfrkl.calculate_msg_length(spec.response))




--------------------------------------------------------------------------------
-- 
-- remote routine prototypes
-- 
--------------------------------------------------------------------------------
@{
# avoid generating duplicate include statements
all_fields = spec.request.parsed_fields() + spec.response.parsed_fields()
# we only care about field types here
for field in genfrkl.utils.uniqify(all_fields, lambda x: x.type):
  if not genfrkl.is_primitive_kl_type(field.type):
    base_name = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)
    print "%%INCLUDE include\lib%s.h" % base_name
}@




--------------------------------------------------------------------------------
-- 
-- local routine prototypes
-- 
--------------------------------------------------------------------------------
%INCLUDE include\@(kl_libname).h




--------------------------------------------------------------------------------
-- 
-- Empty body
-- 
--------------------------------------------------------------------------------
BEGIN
END @(kl_libname)




ROUTINE @(kl_smname)_name
BEGIN
    RETURN (@(kl_smname.upper())_STR_)
END @(kl_smname)_name




ROUTINE @(kl_smname)_pid
BEGIN
    RETURN (@(kl_smname.upper())_PID_)
END @(kl_smname)_pid




--- response routines ----------------------------------------------------------

ROUTINE @(kl_smname)q_len
BEGIN
    RETURN (@(kl_smname.upper())Q_LEN_)
END @(kl_smname)q_len




ROUTINE @(kl_smname)q_name
BEGIN
    RETURN (@(kl_smname.upper())Q_STR_)
END @(kl_smname)q_name




ROUTINE @(kl_smname)q_ctor
BEGIN
    @(kl_smname)q_rset(this)
END @(kl_smname)q_ctor




ROUTINE @(kl_smname)q_rset
@[if genfrkl.has_arrays(spec.request)]@
VAR
    i__          : INTEGER
    array_len__  : INTEGER
@[end if]@
BEGIN
    -- reset each field to its default value
@{
for field in spec.request.parsed_fields():
  kl_type = genfrkl.msg_type_to_kl(spec.request.package, field.type)

  # primitives can be zero-ed using a simple statement
  if genfrkl.is_primitive_kl_type(field.type):
    kl_zero = genfrkl.msg_type_to_zero_value(spec.request.package, field.type)

    # can only reset arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR (i__ = 1 TO array_len__) DO"
      print "        this.%s[i__] = %s" % (field.name, kl_zero)
      print "    ENDFOR"

    # otherwise primitive types can just be set to their 'zero value'
    else:
      kl_zero = genfrkl.msg_type_to_zero_value(spec.request.package, field.type)
      print "    this.%s = %s" % (field.name, kl_zero)

  # not a primitive: assume complex type has '_rset' routine defined somewhere
  else:
    print ("    -- TODO: calling type-specific routines "
          "requires properly generated %INCLUDE directives")

    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.request.package, field.type)

    # can only reset arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR (i__ = 1 TO array_len__) DO"
      print "        %s_rset(this.%s[i__])" % (pfx, field.name)
      print "    ENDFOR"

    # otherwise just call external routine on field
    else:
      print "    %s_rset(this.%s)" % (pfx, field.name)
}@
@{
if genfrkl.msg_has_sm_header(spec.request):
  print ""
  print "    -- finally, init header values"
  print "    this.hdr.msg_type = %d" % mapped_msg_type
  print "    this.hdr.comm_type = SM_CT_SVCREQ"
  print "    this.hdr.reply_code = SM_RC_SUCC"
}@
END @(kl_smname)q_rset




ROUTINE @(kl_smname)_read
VAR
    stat__       : INTEGER
@[if genfrkl.has_arrays(spec.request)]@
    i__          : INTEGER
    array_len__  : INTEGER
@[end if]@
BEGIN
    -- deserialise entire request struct, reading from 'fd'
    stat__ = 0
@{
# first pass: group fields into ranges of primitive and non-primitive fields
field_groups = genfrkl.group_fields(spec.request)

# second pass: emit appropriate READ statements
for field_group in field_groups:
  # improve readability of generated Karel
  print ""

  # we only need to check the type of the first field, as only primitive
  # fields are grouped together
  if genfrkl.is_primitive_kl_type(field_group[0].type):
    # for arrays of primitives we can also generate a compound READ, but we
    # can only read one index at a time, so we need to supply indices
    if field_group[0].is_array:
      array_len = genfrkl.get_array_len(field_group[0].type)

      # KAREL indices start at 1
      array_indices = range(1, array_len + 1)
      array_fields_strs = ['this.%s[%i]' % (field_group[0].name, i) for i in array_indices]
      to_read = ", ".join(array_fields_strs)

    # for non-arrays we can just generate a single compound READ statement
    # for all the fields in the current group
    else:
      to_read = ", ".join(['this.%s' % field.name for field in field_group])

    # wrap & indent for readability
    to_read = "\n            ".join(textwrap.wrap(to_read, LINE_WIDTH))

    # emit read statement
    print "    READ fd(%s)" % to_read
    print "    stat__ = IO_STATUS(fd)"
    print "    IF (stat__ <> 0) THEN RETURN (-stat__); ENDIF"

  # non-primitive group:
  #  - single element in group
  #  - assume complex type has '_read' routine defined somewhere
  else:
    assert (len(field_group) == 1), "BUG: non-primitive group with > 1 element"

    # 
    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.request.package, field_group[0].type)

    print ("    -- TODO: calling type-specific routines "
          "requires properly generated %INCLUDE directives")

    # can only read arrays one field at a time
    if field_group[0].is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field_group[0].name
      print "    FOR (i__ = 1 TO array_len__) DO"
      print "        stat__ = %s_read(this.%s[i__], fd)" % (pfx, field_group[0].name)
      print "        IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
      print "    ENDFOR"

    # otherwise just call external routine on single field
    else:
      print "    stat__ = %s_read(this.%s, fd)" % (pfx, field_group[0].name)
      print "    IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
}@

    RETURN (-ABS(stat__))
END @(kl_smname)_read




ROUTINE @(kl_smname)_sread
VAR
    stat__       : INTEGER
BEGIN
    -- normal read
    stat__ = @(kl_smname)_read(this, fd)
    IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF

    -- swap fields in place
    @(kl_smname)q_swap(this)

    RETURN (-ABS(stat__))
END @(kl_smname)_sread




ROUTINE @(kl_smname)q_tstr
BEGIN
    RETURN (@(kl_smname)q_name)
END @(kl_smname)q_tstr

ROUTINE @(kl_smname)r_tstr
BEGIN
    RETURN (@(kl_smname)r_name)
END @(kl_smname)r_tstr




ROUTINE @(kl_smname)q_dump
VAR
    stat__       : INTEGER
BEGIN
    WRITE fd(@(kl_smname)q_tstr(this), CR)
    stat__ = IO_STATUS(fd)
    RETURN (-ABS(stat__))
END @(kl_smname)q_dump




ROUTINE @(kl_smname)q_swap
@[if genfrkl.has_arrays(spec.request)]@
VAR
    i__          : INTEGER
    array_len__  : INTEGER
@[end if]@
BEGIN
@{
for field in spec.request.parsed_fields():
  # primitives can be swapped-ed using a simple statement
  if genfrkl.is_primitive_kl_type(field.type):
    # only multibyte primitive types need to be swapped
    if not genfrkl.needs_swap(spec.request.package, field.type):
      kl_type = genfrkl.msg_type_to_kl(spec.request.package, field.type)
      print "    -- swap is no-op for field '%s' (type: %s)" % (field.name, kl_type)
      continue

    # can only reset arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR (i__ = 1 TO array_len__) DO"

      kl_type = genfrkl.msg_type_to_kl(spec.request.package, field.type)
      # TODO: this is not really nice, do something about it
      if kl_type == 'SHORT':
        # SHORTs cannot be swapped in place
        print "        %s((this.%s[i__]), temp__); this.%s[i__] = temp__" % (genfrkl.get_swap_func(spec.request.package, field.type), field.name, field.name)
      else:
        print "        %s(this.%s[i__], this.%s[i__])" % (genfrkl.get_swap_func(spec.request.package, field.type), field.name, field.name)
      print "    ENDFOR"

    # otherwise primitive types can just be swapped in-place
    else:
      kl_type = genfrkl.msg_type_to_kl(spec.request.package, field.type)
      # TODO: this is not really nice, do something about it
      if kl_type == 'SHORT':
        # SHORTs cannot be swapped in place
        print "    %s((this.%s), temp__); this.%s = temp__" % (genfrkl.get_swap_func(spec.request.package, field.type), field.name, field.name)
      else:
        print "    %s(this.%s, this.%s)" % (genfrkl.get_swap_func(spec.request.package, field.type), field.name, field.name)

  # not a primitive: assume complex type has '_swap' routine defined somewhere
  else:
    print ("    -- TODO: calling type-specific routines "
          "requires properly generated %INCLUDE directives")

    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.request.package, field.type)

    # can only swap arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR (i__ = 1 TO array_len__) DO"
      print "        %s_swap(this.%s[i__])" % (pfx, field.name)
      print "    ENDFOR"

    # otherwise just call external routine on field
    else:
      print "    %s_swap(this.%s)" % (pfx, field.name)
}@
END @(kl_smname)q_swap




--- response routines ----------------------------------------------------------


ROUTINE @(kl_smname)r_len
BEGIN
    RETURN (@(kl_smname.upper())R_LEN_)
END @(kl_smname)r_len




ROUTINE @(kl_smname)r_name
BEGIN
    RETURN (@(kl_smname.upper())R_STR_)
END @(kl_smname)r_name




ROUTINE @(kl_smname)r_ctor
BEGIN
    @(kl_smname)r_rset(this)
END @(kl_smname)r_ctor




ROUTINE @(kl_smname)r_rset
@[if genfrkl.has_arrays(spec.response)]@
VAR
    i__          : INTEGER
    array_len__  : INTEGER
@[end if]@
BEGIN
    -- reset each field to its default value
@{
for field in spec.response.parsed_fields():
  kl_type = genfrkl.msg_type_to_kl(spec.response.package, field.type)

  # primitives can be zero-ed using a simple statement
  if genfrkl.is_primitive_kl_type(field.type):
    kl_zero = genfrkl.msg_type_to_zero_value(spec.response.package, field.type)

    # can only reset arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR (i__ = 1 TO array_len__) DO"
      print "        this.%s[i__] = %s" % (field.name, kl_zero)
      print "    ENDFOR"

    # otherwise primitive types can just be set to their 'zero value'
    else:
      kl_zero = genfrkl.msg_type_to_zero_value(spec.response.package, field.type)
      print "    this.%s = %s" % (field.name, kl_zero)

  # not a primitive: assume complex type has '_rset' routine defined somewhere
  else:
    print ("    -- TODO: calling type-specific routines "
          "requires properly generated %INCLUDE directives")

    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.response.package, field.type)

    # can only reset arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR (i__ = 1 TO array_len__) DO"
      print "        %s_rset(this.%s[i__])" % (pfx, field.name)
      print "    ENDFOR"

    # otherwise just call external routine on field
    else:
      print "    %s_rset(this.%s)" % (pfx, field.name)
}@
@{
if genfrkl.msg_has_sm_header(spec.response):
  print ""
  print "    -- finally, init header values"
  print "    this.hdr.msg_type = %d" % mapped_msg_type
  print "    this.hdr.comm_type = SM_CT_SVCRPL"
  print "    this.hdr.reply_code = SM_RC_SUCC"
}@
END @(kl_smname)r_rset




ROUTINE @(kl_smname)_wrte
VAR
    stat__       : INTEGER
@[if genfrkl.has_arrays(spec.response)]@
    i__          : INTEGER
    array_len__  : INTEGER
@[end if]@
BEGIN
    -- serialise entire response struct, writing to 'fd'
    stat__ = 0
@{
# first pass: group fields into ranges of primitive and non-primitive fields
field_groups = genfrkl.group_fields(spec.response)

# second pass: emit appropriate WRITE statements
for field_group in field_groups:
  # improve readability of generated Karel
  print ""

  # we only need to check the type of the first field, as only primitive
  # fields are grouped together
  if genfrkl.is_primitive_kl_type(field_group[0].type):
    # for arrays of primitives we can also generate a compound WRITE, but we
    # can only read one index at a time, so we need to supply indices
    if field_group[0].is_array:
      # print "    -- is primitive group - array"
      array_len = genfrkl.get_array_len(field_group[0].type)

      # KAREL indices start at 1
      array_indices = range(1, array_len + 1)
      array_fields_strs = ['this.%s[%i]' % (field_group[0].name, i) for i in array_indices]
      to_write = ", ".join(array_fields_strs)

    # for non-arrays we can just generate a single compound WRITE statement
    # for all the fields in the current group
    else:
      to_write = ", ".join(['this.%s' % field.name for field in field_group])

    # wrap & indent for readability
    to_write = "\n             ".join(textwrap.wrap(to_write, LINE_WIDTH))

    # emit read statement
    print "    WRITE fd(%s, CR)" % to_write
    print "    stat__ = IO_STATUS(fd)"
    print "    IF (stat__ <> 0) THEN RETURN (-stat__); ENDIF"

  # non-primitive group:
  #  - single element in group
  #  - assume complex type has '_wrte' routine defined somewhere
  else:
    assert (len(field_group) == 1), "BUG: non-primitive group with > 1 element"

    # 
    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.response.package, field_group[0].type)

    print ("    -- TODO: calling type-specific routines "
          "requires properly generated %INCLUDE directives")

    # can only write arrays of complex types one element at a time
    if field_group[0].is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field_group[0].name
      print "    FOR (i__ = 1 TO array_len__) DO"
      print "        stat__ = %s_wrte(this.%s[i__], fd)" % (pfx, field_group[0].name)
      print "        IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
      print "    ENDFOR"

    # otherwise just call external routine on single field
    else:
      print "    stat__ = %s_wrte(this.%s, fd)" % (pfx, field_group[0].name)
      print "    IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
}@

    RETURN (-ABS(stat__))
END @(kl_smname)_wrte




ROUTINE @(kl_smname)_swrte
VAR
    stat__       : INTEGER
BEGIN
    -- swap fields in place first
    @(kl_smname)r_swap(this)

    -- now write to 'fd'
    stat__ = @(kl_smname)_wrte(this, fd)
    RETURN (-ABS(stat__))
END @(kl_smname)_swrte




ROUTINE @(kl_smname)r_dump
VAR
    stat__       : INTEGER
BEGIN
    WRITE fd(@(kl_smname)r_tstr(this), CR)
    stat__ = IO_STATUS(fd)
    RETURN (-ABS(stat__))
END @(kl_smname)r_dump




ROUTINE @(kl_smname)r_swap
@[if genfrkl.has_arrays(spec.response)]@
VAR
    i__          : INTEGER
    array_len__  : INTEGER
@[end if]@
BEGIN
@{
for field in spec.response.parsed_fields():
  # primitives can be swapped-ed using a simple statement
  if genfrkl.is_primitive_kl_type(field.type):
    # only multibyte primitive types need to be swapped
    if not genfrkl.needs_swap(spec.response.package, field.type):
      kl_type = genfrkl.msg_type_to_kl(spec.response.package, field.type)
      print "    -- swap is no-op for field '%s' (type: %s)" % (field.name, kl_type)
      continue

    # can only reset arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR (i__ = 1 TO array_len__) DO"

      kl_type = genfrkl.msg_type_to_kl(spec.response.package, field.type)
      # TODO: this is not really nice, do something about it
      if kl_type == 'SHORT':
        # SHORTs cannot be swapped in place
        print "        %s((this.%s[i__]), temp__); this.%s[i__] = temp__" % (genfrkl.get_swap_func(spec.response.package, field.type), field.name, field.name)
      else:
        print "        %s(this.%s[i__], this.%s[i__])" % (genfrkl.get_swap_func(spec.response.package, field.type), field.name, field.name)
      print "    ENDFOR"

    # otherwise primitive types can just be swapped in-place
    else:
      kl_type = genfrkl.msg_type_to_kl(spec.response.package, field.type)
      # TODO: this is not really nice, do something about it
      if kl_type == 'SHORT':
        # SHORTs cannot be swapped in place
        print "    %s((this.%s), temp__); this.%s = temp__" % (genfrkl.get_swap_func(spec.response.package, field.type), field.name, field.name)
      else:
        print "    %s(this.%s, this.%s)" % (genfrkl.get_swap_func(spec.response.package, field.type), field.name, field.name)

  # not a primitive: assume complex type has '_swap' routine defined somewhere
  else:
    print ("    -- TODO: calling type-specific routines "
          "requires properly generated %INCLUDE directives")

    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.response.package, field.type)

    # can only swap arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR (i__ = 1 TO array_len__) DO"
      print "        %s_swap(this.%s[i__])" % (pfx, field.name)
      print "    ENDFOR"

    # otherwise just call external routine on field
    else:
      print "    %s_swap(this.%s)" % (pfx, field.name)
}@
END @(kl_smname)r_swap




--- list routines --------------------------------------------------------------

ROUTINE @(kl_smname)l_ctor
BEGIN
    @(kl_smname)l_cler(this)
    RETURN (0)
END @(kl_smname)l_ctor




ROUTINE @(kl_smname)l_size
BEGIN
    RETURN (PATH_LEN(this))
END @(kl_smname)l_size




ROUTINE @(kl_smname)l_cler
VAR
    i__ : INTEGER
BEGIN
    i__ = @(kl_smname)l_size(this)
    -- TODO: why not just use 'i__'?
    WHILE (@(kl_smname)l_size(this) > 0) DO
        @(kl_smname)l_rmov(this, i__)
        i__ = @(kl_smname)l_size(this)
    ENDWHILE
END @(kl_smname)l_cler




ROUTINE @(kl_smname)l_add
VAR
    stat__ : INTEGER
    tmp__  : INTEGER
BEGIN
    APPEND_NODE(this, stat__)
    -- TODO: check status of operation
    tmp__ = @(kl_smname)l_size(this)
    this[tmp__] = e
END @(kl_smname)l_add




ROUTINE @(kl_smname)l_apnd
BEGIN
    @(kl_smname)l_add(this, e)
END @(kl_smname)l_apnd




ROUTINE @(kl_smname)l_set
VAR
    tmp__  : @(kl_smname)_lit_t
    stat__ : INTEGER
BEGIN
    tmp__ = @(kl_smname)l_get(this, idx)
    this[idx] = e
    RETURN (tmp__)
END @(kl_smname)l_set




ROUTINE @(kl_smname)l_get
BEGIN
    RETURN (this[idx])
END @(kl_smname)l_get




ROUTINE @(kl_smname)l_take
VAR
    tmp__  : @(kl_smname)_lit_t
    stat__ : INTEGER
BEGIN
    tmp__ = @(kl_smname)l_get(this, idx)
    DELETE_NODE(this, idx, stat__)
    -- TODO: check status of operation
    RETURN (tmp__)
END @(kl_smname)l_take




ROUTINE @(kl_smname)l_rmov
VAR
    stat__ : INTEGER
BEGIN
    DELETE_NODE(this, idx, stat__)
    -- TODO: check status of operation
END @(kl_smname)l_rmov




ROUTINE @(kl_smname)l_mpty
BEGIN
    RETURN (@(kl_smname)l_size(this) = 0)
END @(kl_smname)l_mpty




ROUTINE @(kl_smname)l_ins
VAR
    stat__ : INTEGER
BEGIN
    INSERT_NODE(this, idx, stat__)
    -- TODO: check status of operation
    this[idx] = e
END @(kl_smname)l_ins


--- /list routines -------------------------------------------------------------
