@####################################################
@#
@# Copyright 2015 TU Delft Robotics Institute
@#
@# Licensed under the Apache License, Version 2.0 (the "License");
@# you may not use this file except in compliance with the License.
@# You may obtain a copy of the License at
@#
@#     http://www.apache.org/licenses/LICENSE-2.0
@#
@# Unless required by applicable law or agreed to in writing, software
@# distributed under the License is distributed on an "AS IS" BASIS,
@# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@# See the License for the specific language governing permissions and
@# limitations under the License.
@#
@# author: G.A. vd. Hoorn (TU Delft Robotics Institute)
@#
@####################################################
@#
@# ROS service source code generation for Fanuc Karel
@#
@# EmPy template for generating <srv>.kl files
@#
@####################################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .srv file
@#  - md5sum (String) MD5Sum of the .srv specification
@#
@####################################################
@{
import genfrkl
import genfrkl.utils
import genfrkl.karel

import textwrap

# global settings
LINE_WIDTH = 72
}@


PROGRAM @(kl_libname)
--------------------------------------------------------------------------------
--
-- @(spec.package)/@(spec.short_name) (@(kl_libname)) library implementation.
--
-- Autogenerated by genmsg_frkl from @file_name_in
--
-- MD5 of source ROS msg: @md5sum
--
--------------------------------------------------------------------------------
%ALPHABETIZE
%COMMENT = 'ROS//r0  @md5sum[:6]'
%NOBUSYLAMP
%NOLOCKGROUP
%NOPAUSE = COMMAND + TPENABLE + ERROR




--------------------------------------------------------------------------------
--
-- remote types & constants
--
--------------------------------------------------------------------------------
%INCLUDE include\ktype_sz.th
@{
# need only single statement per complex type
for _type, type_info in mapped_types.iteritems():
    if not genfrkl.karel.is_primitive_type(type_info.tgt_type):
        print "%%INCLUDE include\lib%s.th    -- %s" % (type_info.tgt_type_pfx, type_info.src_type)
}@




--------------------------------------------------------------------------------
--
-- local types & constants
--
--------------------------------------------------------------------------------
%INCLUDE include\@(kl_libname).th

CONST
    -- internal use only
    @(kl_smname.upper())_PID_  = @(kl_smname.upper())_ID
    @(kl_smname.upper())_STR_  = '@(spec.short_name)'
    @(kl_smname.upper())Q_STR_ = '@(spec.short_name)_Request'
    @(kl_smname.upper())Q_LEN_ = @('%d' % genfrkl.calculate_msg_length(spec.request))
    @(kl_smname.upper())R_STR_ = '@(spec.short_name)_Response'
    @(kl_smname.upper())R_LEN_ = @('%d' % genfrkl.calculate_msg_length(spec.response))




--------------------------------------------------------------------------------
--
-- remote routine prototypes
--
--------------------------------------------------------------------------------
@{
# need only single statement per complex type
for _type, type_info in mapped_types.iteritems():
    if not genfrkl.karel.is_primitive_type(type_info.tgt_type):
        print "%%INCLUDE include\lib%s.h    -- %s" % (type_info.tgt_type_pfx, type_info.src_type)
}@




--------------------------------------------------------------------------------
--
-- local routine prototypes
--
--------------------------------------------------------------------------------
%INCLUDE include\@(kl_libname).h




--------------------------------------------------------------------------------
--
-- Empty body
--
--------------------------------------------------------------------------------
BEGIN
END @(kl_libname)




ROUTINE @(kl_smname)_name
BEGIN
	RETURN (@(kl_smname.upper())_STR_)
END @(kl_smname)_name




ROUTINE @(kl_smname)_pid
BEGIN
	RETURN (@(kl_smname.upper())_PID_)
END @(kl_smname)_pid




--- response routines ----------------------------------------------------------

ROUTINE @(kl_smname)q_len
BEGIN
	RETURN (@(kl_smname.upper())Q_LEN_)
END @(kl_smname)q_len




ROUTINE @(kl_smname)q_name
BEGIN
	RETURN (@(kl_smname.upper())Q_STR_)
END @(kl_smname)q_name




ROUTINE @(kl_smname)q_ctor
BEGIN
	@(kl_smname)q_rset(this)
END @(kl_smname)q_ctor




ROUTINE @(kl_smname)q_rset
@[if genfrkl.utils.has_arrays(spec.request)]@
VAR
	i__          : INTEGER
@[end if]@
BEGIN
	-- reset each field to its default value
@{
for field in spec.request.parsed_fields():
    mapped_type = mapped_types[field.base_type]

    # primitives can be zero-ed using a simple statement
    if genfrkl.karel.is_primitive_type(mapped_type.tgt_type):
        zero_value = genfrkl.karel.primitive_zero_value(mapped_type.tgt_type)

        # can only reset arrays one field at a time
        if field.is_array:
            print "\tFOR (i__ = 1 TO %d) DO" % field.array_len
            print "\t\tthis.%s[i__] = %s" % (field.name, zero_value)
            print "\tENDFOR"

        # otherwise primitive types can just be set to their 'zero value'
        else:
            print "\tthis.%s = %s" % (field.name, zero_value)

    # not a primitive: assume complex type has '_rset' routine defined somewhere
    else:
        # can only reset arrays one field at a time
        if field.is_array:
            print "\tFOR (i__ = 1 TO %d) DO" % field.array_len
            print "\t\t%s_rset(this.%s[i__])" % (mapped_type.tgt_type_pfx, field.name)
            print "\tENDFOR"

        # otherwise just call external routine on field
        else:
            print "\t%s_rset(this.%s)" % (mapped_type.tgt_type_pfx, field.name)
}@
@{
# if genfrkl.msg_has_sm_header(spec.request):
#   print ""
#   print "    -- finally, init header values"
#   print "    this.hdr.msg_type = %d" % mapped_msg_type
#   print "    this.hdr.comm_type = SM_CT_SVCREQ"
#   print "    this.hdr.reply_code = SM_RC_SUCC"
}@
END @(kl_smname)q_rset




ROUTINE @(kl_smname)_read
VAR
	stat__       : INTEGER
@[if genfrkl.utils.has_arrays(spec.request)]@
	i__          : INTEGER
@[end if]@
BEGIN
	-- deserialise entire request struct, reading from 'fd'
	stat__ = 0
@{
# first pass: group fields into ranges of primitive and non-primitive fields
field_groups = genfrkl.group_fields(spec.request)

# second pass: emit appropriate READ statements
for field_group in field_groups:
    # improve readability of generated Karel
    print ""

    # fail early: we only support arrays with a length
    if field_group[0].is_array and field_group[0].array_len is None:
        raise ValueError("Lists are currently not supported ('%s' is an array"
            " without length)." % field_group[0].name)

    # we only need to check the type of the first field, as only primitive
    # fields are grouped together
    mapped_type = mapped_types[field_group[0].base_type]
    if genfrkl.karel.is_primitive_type(mapped_type.tgt_type):

        # for arrays of primitives we can also generate a compound READ, but we
        # can only read one index at a time, so we need to supply indices
        if field_group[0].is_array:
            # KAREL indices start at 1
            array_indices = range(1, field_group[0].array_len + 1)
            array_fields_strs = ['this.%s[%i]' % (field_group[0].name, i) for i in array_indices]
            to_read = ", ".join(array_fields_strs)

        # for non-arrays we can just generate a single compound READ statement
        # for all the fields in the current group
        else:
            to_read = ", ".join(['this.%s' % field.name for field in field_group])

        # wrap & indent for readability
        to_read = "\n\t        ".join(textwrap.wrap(to_read, LINE_WIDTH))

        # emit read statement
        print "\tREAD fd(%s)" % to_read
        print "\tstat__ = IO_STATUS(fd)"
        print "\tIF (stat__ <> 0) THEN RETURN (-stat__); ENDIF"

    # non-primitive group:
    #  - single element in group
    #  - assume complex type has '_read' routine defined somewhere
    else:
        assert (len(field_group) == 1), "BUG: non-primitive group with > 1 element"

        # can only read arrays one field at a time
        if field_group[0].is_array:
            print "\tFOR (i__ = 1 TO %d) DO" % field_group[0].array_len
            print "\t\tstat__ = %s_read(this.%s[i__], fd)" % (mapped_type.tgt_type_pfx, field_group[0].name)
            print "\t\tIF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
            print "\tENDFOR"

        # otherwise just call external routine on single field
        else:
            print "\tstat__ = %s_read(this.%s, fd)" % (mapped_type.tgt_type_pfx, field_group[0].name)
            print "\tIF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
}@

	RETURN (-ABS(stat__))
END @(kl_smname)_read




ROUTINE @(kl_smname)_sread
VAR
	stat__       : INTEGER
BEGIN
	-- normal read
	stat__ = @(kl_smname)_read(this, fd)
	IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF

	-- swap fields in place
	@(kl_smname)q_swap(this)

	RETURN (-ABS(stat__))
END @(kl_smname)_sread




ROUTINE @(kl_smname)q_tstr
BEGIN
	RETURN (@(kl_smname)q_name)
END @(kl_smname)q_tstr

ROUTINE @(kl_smname)r_tstr
BEGIN
	RETURN (@(kl_smname)r_name)
END @(kl_smname)r_tstr




ROUTINE @(kl_smname)q_dump
VAR
	stat__       : INTEGER
BEGIN
	WRITE fd(@(kl_smname)q_tstr(this), CR)
	stat__ = IO_STATUS(fd)
	RETURN (-ABS(stat__))
END @(kl_smname)q_dump




ROUTINE @(kl_smname)q_swap
@[if genfrkl.utils.has_arrays(spec.request)]@
VAR
	i__          : INTEGER
	temp__       : INTEGER
@[end if]@
BEGIN
@{
for field in spec.request.parsed_fields():
    mapped_type = mapped_types[field.base_type]

    # primitives can be swapped-ed using a simple statement
    if genfrkl.karel.is_primitive_type(mapped_type.tgt_type):
        # only multibyte primitive types need to be swapped
        if not genfrkl.karel.has_swap_function(mapped_type.tgt_type):
            print "\t-- swap is no-op for field '%s' (type: %s)" % (field.name, mapped_type.tgt_type)
            continue

        swap_fn = genfrkl.karel.get_swap_function(mapped_type.tgt_type)

        # can only reset arrays one field at a time
        if field.is_array:
            print "\tFOR (i__ = 1 TO %d) DO" % field.array_len

            # TODO: this is not really nice, do something about it
            if mapped_type.tgt_type == 'SHORT':
                # SHORTs cannot be swapped in place
                print "\t\t%s((this.%s[i__]), temp__); this.%s[i__] = temp__" % (swap_fn, field.name, field.name)
            else:
                print "\t\t%s(this.%s[i__], this.%s[i__])" % (swap_fn, field.name, field.name)
            print "\tENDFOR"

        # otherwise primitive types can just be swapped in-place
        else:
            # TODO: this is not really nice, do something about it
            if mapped_type.tgt_type == 'SHORT':
                # SHORTs cannot be swapped in place
                print "\t%s((this.%s), temp__); this.%s = temp__" % (swap_fn, field.name, field.name)
            else:
                print "\t%s(this.%s, this.%s)" % (swap_fn, field.name, field.name)

    # not a primitive: assume complex type has '_swap' routine defined somewhere
    else:
        # can only swap arrays one field at a time
        if field.is_array:
            print "\tFOR (i__ = 1 TO %d) DO" % field.array_len
            print "\t\t%s_swap(this.%s[i__])" % (mapped_type.tgt_type_pfx, field.name)
            print "\tENDFOR"

        # otherwise just call external routine on field
        else:
            print "\t%s_swap(this.%s)" % (mapped_type.tgt_type_pfx, field.name)
}@
END @(kl_smname)q_swap




--- response routines ----------------------------------------------------------


ROUTINE @(kl_smname)r_len
BEGIN
	RETURN (@(kl_smname.upper())R_LEN_)
END @(kl_smname)r_len




ROUTINE @(kl_smname)r_name
BEGIN
	RETURN (@(kl_smname.upper())R_STR_)
END @(kl_smname)r_name




ROUTINE @(kl_smname)r_ctor
BEGIN
	@(kl_smname)r_rset(this)
END @(kl_smname)r_ctor




ROUTINE @(kl_smname)r_rset
@[if genfrkl.utils.has_arrays(spec.response)]@
VAR
	i__          : INTEGER
@[end if]@
BEGIN
	-- reset each field to its default value
@{
for field in spec.response.parsed_fields():
    mapped_type = mapped_types[field.base_type]

    # primitives can be zero-ed using a simple statement
    if genfrkl.karel.is_primitive_type(mapped_type.tgt_type):
        zero_value = genfrkl.karel.primitive_zero_value(mapped_type.tgt_type)

        # can only reset arrays one field at a time
        if field.is_array:
            print "\tFOR (i__ = 1 TO %d) DO" % field.array_len
            print "\t\tthis.%s[i__] = %s" % (field.name, zero_value)
            print "\tENDFOR"

        # otherwise primitive types can just be set to their 'zero value'
        else:
            print "\tthis.%s = %s" % (field.name, zero_value)

    # not a primitive: assume complex type has '_rset' routine defined somewhere
    else:
        # can only reset arrays one field at a time
        if field.is_array:
            print "\tFOR (i__ = 1 TO %d) DO" % field.array_len
            print "\t\t%s_rset(this.%s[i__])" % (mapped_type.tgt_type_pfx, field.name)
            print "\tENDFOR"

        # otherwise just call external routine on field
        else:
            print "\t%s_rset(this.%s)" % (mapped_type.tgt_type_pfx, field.name)
}@
@{
#if genfrkl.msg_has_sm_header(spec.response):
#  print ""
#  print "    -- finally, init header values"
#  print "    this.hdr.msg_type = %d" % mapped_msg_type
#  print "    this.hdr.comm_type = SM_CT_SVCRPL"
#  print "    this.hdr.reply_code = SM_RC_SUCC"
#}@
END @(kl_smname)r_rset




ROUTINE @(kl_smname)_wrte
VAR
	stat__       : INTEGER
@[if genfrkl.utils.has_arrays(spec.response)]@
	i__          : INTEGER
@[end if]@
BEGIN
	-- serialise entire response struct, writing to 'fd'
	stat__ = 0
@{
# first pass: group fields into ranges of primitive and non-primitive fields
field_groups = genfrkl.group_fields(spec.response)

# second pass: emit appropriate WRITE statements
for field_group in field_groups:
    # improve readability of generated Karel
    print ""

    # fail early: we only support arrays with a length
    if field_group[0].is_array and field_group[0].array_len is None:
        raise ValueError("Lists are currently not supported ('%s' is an array"
            " without length)." % field_group[0].name)

    # we only need to check the type of the first field, as only primitive
    # fields are grouped together
    mapped_type = mapped_types[field_group[0].base_type]
    if genfrkl.karel.is_primitive_type(mapped_type.tgt_type):
        # for arrays of primitives we can also generate a compound WRITE, but we
        # can only read one index at a time, so we need to supply indices
        if field_group[0].is_array:
            # KAREL indices start at 1
            array_indices = range(1, field_group[0].array_len + 1)
            array_fields_strs = ['this.%s[%i]' % (field_group[0].name, i) for i in array_indices]
            to_write = ", ".join(array_fields_strs)

        # for non-arrays we can just generate a single compound WRITE statement
        # for all the fields in the current group
        else:
            to_write = ", ".join(['this.%s' % field.name for field in field_group])

        # wrap & indent for readability
        to_write = "\n\t         ".join(textwrap.wrap(to_write, LINE_WIDTH))

        # emit read statement
        print "\tWRITE fd(%s, CR)" % to_write
        print "\tstat__ = IO_STATUS(fd)"
        print "\tIF (stat__ <> 0) THEN RETURN (-stat__); ENDIF"

    # non-primitive group:
    #  - single element in group
    #  - assume complex type has '_wrte' routine defined somewhere
    else:
        assert (len(field_group) == 1), "BUG: non-primitive group with > 1 element"

        # can only write arrays of complex types one element at a time
        if field_group[0].is_array:
            print "\tFOR (i__ = 1 TO %d) DO" % field_group[0].array_len
            print "\t\tstat__ = %s_wrte(this.%s[i__], fd)" % (mapped_type.tgt_type_pfx, field_group[0].name)
            print "\t\tIF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
            print "\tENDFOR"

        # otherwise just call external routine on single field
        else:
            print "\tstat__ = %s_wrte(this.%s, fd)" % (mapped_type.tgt_type_pfx, field_group[0].name)
            print "\tIF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
}@

	RETURN (-ABS(stat__))
END @(kl_smname)_wrte




ROUTINE @(kl_smname)_swrte
VAR
	stat__       : INTEGER
BEGIN
	-- swap fields in place first
	@(kl_smname)r_swap(this)

	-- now write to 'fd'
	stat__ = @(kl_smname)_wrte(this, fd)
	RETURN (-ABS(stat__))
END @(kl_smname)_swrte




ROUTINE @(kl_smname)r_dump
VAR
	stat__       : INTEGER
BEGIN
	WRITE fd(@(kl_smname)r_tstr(this), CR)
	stat__ = IO_STATUS(fd)
	RETURN (-ABS(stat__))
END @(kl_smname)r_dump




ROUTINE @(kl_smname)r_swap
@[if genfrkl.utils.has_arrays(spec.response)]@
VAR
	i__          : INTEGER
@[end if]@
BEGIN
@{
for field in spec.response.parsed_fields():
    mapped_type = mapped_types[field.base_type]

    # primitives can be swapped-ed using a simple statement
    if genfrkl.karel.is_primitive_type(mapped_type.tgt_type):
        # only multibyte primitive types need to be swapped
        if not genfrkl.karel.has_swap_function(mapped_type.tgt_type):
            print "\t-- swap is no-op for field '%s' (type: %s)" % (field.name, mapped_type.tgt_type)
            continue

        swap_fn = genfrkl.karel.get_swap_function(mapped_type.tgt_type)

        # can only reset arrays one field at a time
        if field.is_array:
            print "\tFOR (i__ = 1 TO %d) DO" % field.array_len

            # TODO: this is not really nice, do something about it
            if mapped_type.tgt_type == 'SHORT':
                # SHORTs cannot be swapped in place
                print "\t\t%s((this.%s[i__]), temp__); this.%s[i__] = temp__" % (swap_fn, field.name, field.name)
            else:
                print "\t\t%s(this.%s[i__], this.%s[i__])" % (swap_fn, field.name, field.name)
            print "\tENDFOR"

        # otherwise primitive types can just be swapped in-place
        else:
            # TODO: this is not really nice, do something about it
            if mapped_type.tgt_type == 'SHORT':
                # SHORTs cannot be swapped in place
                print "\t%s((this.%s), temp__); this.%s = temp__" % (swap_fn, field.name, field.name)
            else:
                print "\t%s(this.%s, this.%s)" % (swap_fn, field.name, field.name)

    # not a primitive: assume complex type has '_swap' routine defined somewhere
    else:
        # can only swap arrays one field at a time
        if field.is_array:
            print "\tFOR (i__ = 1 TO %d) DO" % field.array_len
            print "\t\t%s_swap(this.%s[i__])" % (mapped_type.tgt_type_pfx, field.name)
            print "\tENDFOR"

        # otherwise just call external routine on field
        else:
            print "\t%s_swap(this.%s)" % (mapped_type.tgt_type_pfx, field.name)
}@
END @(kl_smname)r_swap




--- list routines --------------------------------------------------------------

ROUTINE @(kl_smname)l_ctor
BEGIN
	@(kl_smname)l_cler(this)
	RETURN (0)
END @(kl_smname)l_ctor




ROUTINE @(kl_smname)l_size
BEGIN
	RETURN (PATH_LEN(this))
END @(kl_smname)l_size




ROUTINE @(kl_smname)l_cler
VAR
	i__ : INTEGER
BEGIN
	i__ = @(kl_smname)l_size(this)
	-- TODO: why not just use 'i__'?
	WHILE (@(kl_smname)l_size(this) > 0) DO
		@(kl_smname)l_rmov(this, i__)
		i__ = @(kl_smname)l_size(this)
	ENDWHILE
END @(kl_smname)l_cler




ROUTINE @(kl_smname)l_add
VAR
	stat__ : INTEGER
	tmp__  : INTEGER
BEGIN
	APPEND_NODE(this, stat__)
	-- TODO: check status of operation
	tmp__ = @(kl_smname)l_size(this)
	this[tmp__] = e
END @(kl_smname)l_add




ROUTINE @(kl_smname)l_apnd
BEGIN
	@(kl_smname)l_add(this, e)
END @(kl_smname)l_apnd




ROUTINE @(kl_smname)l_set
VAR
	tmp__  : @(kl_smname)_lit_t
	stat__ : INTEGER
BEGIN
	tmp__ = @(kl_smname)l_get(this, idx)
	this[idx] = e
	RETURN (tmp__)
END @(kl_smname)l_set




ROUTINE @(kl_smname)l_get
BEGIN
	RETURN (this[idx])
END @(kl_smname)l_get




ROUTINE @(kl_smname)l_take
VAR
	tmp__  : @(kl_smname)_lit_t
	stat__ : INTEGER
BEGIN
	tmp__ = @(kl_smname)l_get(this, idx)
	DELETE_NODE(this, idx, stat__)
	-- TODO: check status of operation
	RETURN (tmp__)
END @(kl_smname)l_take




ROUTINE @(kl_smname)l_rmov
VAR
	stat__ : INTEGER
BEGIN
	DELETE_NODE(this, idx, stat__)
	-- TODO: check status of operation
END @(kl_smname)l_rmov




ROUTINE @(kl_smname)l_mpty
BEGIN
	RETURN (@(kl_smname)l_size(this) = 0)
END @(kl_smname)l_mpty




ROUTINE @(kl_smname)l_ins
VAR
	stat__ : INTEGER
BEGIN
	INSERT_NODE(this, idx, stat__)
	-- TODO: check status of operation
	this[idx] = e
END @(kl_smname)l_ins


--- /list routines -------------------------------------------------------------
