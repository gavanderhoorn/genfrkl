@####################################################
@#
@# ROS message source code generation for Fanuc Karel
@#
@# EmPy template for generating <msg>.t.kl files
@#
@####################################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .msg file
@#  - md5sum (String) MD5Sum of the .msg specification
@#
@####################################################
-- 
-- 
-- 
@{
import genmsg.msgs
import genfrkl

import textwrap


# 10
mapped_msg_type = genfrkl.msg_to_simple_message_type(spec)

# '000A'
msg_mapped_id_hex = '%04X' % mapped_msg_type

# 'rp000A'
kl_rpname = 'rp%04X' % mapped_msg_type

# 'rp000A_t'
kl_structname = 'rp%04X_t' % mapped_msg_type

# 'librp000A'
kl_libname = 'librp%04X' % mapped_msg_type
}



PROGRAM @(kl_libname)
--------------------------------------------------------------------------------
-- 
-- @(kl_libname) (@(spec.package)/@(spec.short_name)) library implementation.
-- 
-- Autogenerated by genmsg_kl from @file_name_in
-- 
-- MD5 of source ROS msg: @md5sum
-- 
-- author: G.A. vd. Hoorn (TU Delft Robotics Institute)
-- 
--------------------------------------------------------------------------------
%ALPHABETIZE
%NOLOCKGROUP
%NOPAUSE= COMMAND + TPENABLE + ERROR
%COMMENT = 'r0'




--------------------------------------------------------------------------------
-- 
-- remote types & constants
-- 
--------------------------------------------------------------------------------
%INCLUDE ktype_sz.th
@{
for field in spec.parsed_fields():
  if not genfrkl.is_primitive_kl_type(field.type):
    base_name = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)
    print "%%INCLUDE ros\lib%s.th" % base_name
}@




--------------------------------------------------------------------------------
-- 
-- local types & constants
-- 
--------------------------------------------------------------------------------
%INCLUDE ros\@(kl_libname).th

--CONST
    -- internal use only
    --JNTPOS_ID_   = @(kl_rpname.upper())_PID_C
    --JNTPOS_STR_  = 'msg_type_todo'
    --JNTPOS_LEN_  = @('%d' % genfrkl.calculate_msg_length(spec))
    -- TODO: fixup constant gen




--------------------------------------------------------------------------------
-- 
-- remote routine prototypes
-- 
--------------------------------------------------------------------------------
@{
for field in spec.parsed_fields():
  if not genfrkl.is_primitive_kl_type(field.type):
    base_name = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)
    print "%%INCLUDE ros\lib%s.h" % base_name
}@




--------------------------------------------------------------------------------
-- 
-- local routine prototypes
-- 
--------------------------------------------------------------------------------
%INCLUDE ros\@(kl_libname).h




--------------------------------------------------------------------------------
-- 
-- Empty body
-- 
--------------------------------------------------------------------------------
BEGIN
END @(kl_libname)




ROUTINE @(kl_rpname)_len
BEGIN
@{
# 
# totale lengte is: sum(sizeof(field : fields))
#  - len primitives is bekend (need map to ktype_sz.t consts)
#  - len arrays: len(base_type) * array_len(field)
#  - len complex types: COMPLEX_TYPE_len(field)
# 
}
    RETURN (@(genfrkl.calculate_msg_length(spec)))
END @(kl_rpname)_len




ROUTINE @(kl_rpname)_name
BEGIN
    RETURN ('@(spec.short_name)')
END @(kl_rpname)_name




ROUTINE @(kl_rpname)_pid
BEGIN
    RETURN (RP@(msg_mapped_id_hex.upper())_ID)
END @(kl_rpname)_pid




ROUTINE @(kl_rpname)_ctor
BEGIN
    @(kl_rpname)_rset(this)
END @(kl_rpname)_ctor




ROUTINE @(kl_rpname)_rset
@[if genfrkl.has_arrays(spec)]@
VAR
    i__          : INTEGER -- TODO: only add vars if necessary
    array_len__  : INTEGER
@[end if]@
BEGIN
    -- reset each field to its default value
@{
for field in spec.parsed_fields():
  # improve readability of generated Karel
  print ""

  kl_type = genfrkl.msg_type_to_kl(spec.package, field.type)

  # primitives can be zero-ed using a simple statement
  if genfrkl.is_primitive_kl_type(field.type):
    kl_zero = genfrkl.msg_type_to_zero_value(spec.package, field.type)

    # can only reset arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR i__ = 1 TO array_len__ DO"
      print "        this.%s[i__] = %s" % (field.name, kl_zero)
      print "    ENDFOR"

    # otherwise primitive types can just be set to their 'zero value'
    else:
      kl_zero = genfrkl.msg_type_to_zero_value(spec.package, field.type)
      print "    this.%s = %s" % (field.name, kl_zero)

  # not a primitive: assume complex type has '_rset' routine defined somewhere
  else:
    print ("    -- TODO: calling type-specific routines "
          "requires properly generated %INCLUDE directives")

    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)

    # can only reset arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR i__ = 1 TO array_len__ DO"
      print "        %s_rset(this.%s[i__])" % (pfx, field.name)
      print "    ENDFOR"

    # otherwise just call external routine on field
    else:
      print "    %s_rset(this.%s)" % (pfx, field.name)
}@
END @(kl_rpname)_rset




ROUTINE @(kl_rpname)_read
VAR
    stat__       : INTEGER
    i__          : INTEGER
    array_len__  : INTEGER
BEGIN
    -- deserialise entire struct, reading from 'fd'
@{
# first pass: group fields into ranges of primitive and non-primitive fields
field_groups = genfrkl.group_fields(spec)

# second pass: emit appropriate READ statements
for field_group in field_groups:
  # improve readability of generated Karel
  print ""

  # we only need to check the type of the first field, as only primitive
  # fields are grouped together
  if genfrkl.is_primitive_kl_type(field_group[0].type):
    # for arrays of primitives we can also generate a compound READ, but we
    # can only read one index at a time, so we need to supply indices
    if field_group[0].is_array:
      array_len = genfrkl.get_array_len(field_group[0].type)

      # KAREL indices start at 1
      array_indices = range(1, array_len + 1)
      array_fields_strs = ['this.%s[%i]' % (field_group[0].name, i) for i in array_indices]
      to_read = ", ".join(array_fields_strs)

    # for non-arrays we can just generate a single compound READ statement
    # for all the fields in the current group
    else:
      to_read = ", ".join(['this.%s' % field.name for field in field_group])

    # wrap & indent for readability
    to_read = "\n            ".join(textwrap.wrap(to_read, 72))

    # emit read statement
    print "    READ fd(%s)" % to_read
    print "    stat__ = IO_STATUS(fd)"
    print "    IF (stat__ <> 0) THEN RETURN (-stat__); ENDIF"

  # non-primitive group:
  #  - single element in group
  #  - assume complex type has '_read' routine defined somewhere
  else:
    assert (len(field_group) == 1), "BUG: non-primitive group with > 1 element"

    # readability
    field = field_group[0]
    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)

    print ("    -- TODO: calling type-specific routines "
          "requires properly generated %INCLUDE directives")

    # can only read arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR i__ = 1 TO array_len__ DO"
      print "        stat__ = %s_read(this.%s[i__], fd)" % (pfx, field.name)
      print "        IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
      print "    ENDFOR"

    # otherwise just call external routine on single field
    else:
      print "    stat__ = %s_read(this.%s, fd)" % (pfx, field.name)
      print "    IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
}@

    RETURN (-ABS(stat__))
END @(kl_rpname)_read




ROUTINE @(kl_rpname)_sread
BEGIN
    -- TODO: implement swapping read
    RETURN (@(kl_rpname)_read(this, fd))
END @(kl_rpname)_sread




ROUTINE @(kl_rpname)_wrte
VAR
    stat__       : INTEGER
    i__          : INTEGER
    array_len__  : INTEGER
BEGIN
    -- serialise entire struct, writing to 'fd'
@{
# first pass: group fields into ranges of primitive and non-primitive fields
field_groups = genfrkl.group_fields(spec)

# second pass: emit appropriate WRITE statements
for field_group in field_groups:
  # improve readability of generated Karel
  print ""

  # we only need to check the type of the first field, as only primitive
  # fields are grouped together
  if genfrkl.is_primitive_kl_type(field_group[0].type):
    # for arrays of primitives we can also generate a compound WRITE, but we
    # can only read one index at a time, so we need to supply indices
    if field_group[0].is_array:
      # print "    -- is primitive group - array"
      array_len = genfrkl.get_array_len(field_group[0].type)

      # KAREL indices start at 1
      array_indices = range(1, array_len + 1)
      array_fields_strs = ['this.%s[%i]' % (field_group[0].name, i) for i in array_indices]
      to_write = ", ".join(array_fields_strs)

    # for non-arrays we can just generate a single compound WRITE statement
    # for all the fields in the current group
    else:
      to_write = ", ".join(['this.%s' % field.name for field in field_group])

    # wrap & indent for readability
    to_write = "\n             ".join(textwrap.wrap(to_write, 72))

    # emit read statement
    print "    WRITE fd(%s, CR)" % to_write
    print "    stat__ = IO_STATUS(fd)"
    print "    IF (stat__ <> 0) THEN RETURN (-stat__); ENDIF"

  # non-primitive group:
  #  - single element in group
  #  - assume complex type has '_wrte' routine defined somewhere
  else:
    assert (len(field_group) == 1), "BUG: non-primitive group with > 1 element"

    # readability
    field = field_group[0]
    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)

    print ("    -- TODO: calling type-specific routines "
          "requires properly generated %INCLUDE directives")

    # can only write arrays of complex types one element at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR i__ = 1 TO array_len__ DO"
      print "        stat__ = %s_wrte(this.%s[i__], fd)" % (pfx, field.name)
      print "        IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
      print "    ENDFOR"

    # otherwise just call external routine on single field
    else:
      print "    stat__ = %s_wrte(this.%s, fd)" % (pfx, field.name)
      print "    IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
}@

    RETURN (-ABS(stat__))
END @(kl_rpname)_wrte




ROUTINE @(kl_rpname)_swrte
BEGIN
    -- TODO: implement swapping write
    RETURN (@(kl_rpname)_wrte(this, fd))
END @(kl_rpname)_swrte




ROUTINE @(kl_rpname)_tstr
--VAR
--    seq_str__    : STRING[10]
BEGIN
    -- returns: joint_position(hdr(..), ..)
    -- TODO: possibly make use of int2str() routine
    -- TODO: perhaps use @file_name_in or @spec.short_name?

    --CNV_INT_STR(this.seq, 1, 10, seq_str__)
    RETURN ('@(spec.short_name)(' &
        + rp_hdr_tstr(this.hdr) + ',' &
        + ')')
--        + seq_str__ &
END @(kl_rpname)_tstr




ROUTINE @(kl_rpname)_dump
VAR
    stat__       : INTEGER
BEGIN
    WRITE fd(@(kl_rpname)_tstr(this), CR)
    stat__ = IO_STATUS(fd)
    RETURN (-ABS(stat__))
END @(kl_rpname)_dump
