@####################################################
@#
@# ROS message source code generation for Fanuc Karel
@#
@# EmPy template for generating <msg>.t.kl files
@#
@####################################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .msg file
@#  - md5sum (String) MD5Sum of the .msg specification
@#
@###############################################
-- 
-- 
-- 
@{
import genmsg.msgs
import genfrkl


# 10
mapped_msg_type = genfrkl.msg_to_simple_message_type(spec)

# '000A'
msg_mapped_id_hex = '%04X' % mapped_msg_type

# 'rp000A'
kl_rpname = 'rp%04X' % mapped_msg_type

# 'rp000A_t'
kl_structname = 'rp%04X_t' % mapped_msg_type

# 'librp000A'
kl_libname = 'librp%04X' % mapped_msg_type
}



PROGRAM @(kl_libname)
--------------------------------------------------------------------------------
-- 
-- @(kl_libname) (@(spec.package)/@(spec.short_name)) library implementation.
-- 
-- Autogenerated by genmsg_kl from @file_name_in
-- 
-- MD5 of source ROS msg: @md5sum
-- 
-- author: G.A. vd. Hoorn (TU Delft Robotics Institute)
-- 
--------------------------------------------------------------------------------
%ALPHABETIZE
%NOLOCKGROUP
%NOPAUSE= COMMAND + TPENABLE + ERROR
%COMMENT = 'r0'




--------------------------------------------------------------------------------
-- 
-- remote types & constants
-- 
--------------------------------------------------------------------------------
%INCLUDE ktype_sz.th
@{
for field in spec.parsed_fields():
  if not genfrkl.is_primitive_kl_type(field.type):
    base_name = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)
    print "%%INCLUDE ros\lib%s.th" % base_name
}@




--------------------------------------------------------------------------------
-- 
-- local types & constants
-- 
--------------------------------------------------------------------------------
%INCLUDE ros\@(kl_libname).th

--CONST
    -- internal use only
    --JNTPOS_ID_   = @(kl_rpname.upper())_PID_C
    --JNTPOS_STR_  = 'msg_type_todo'
    --JNTPOS_LEN_  = @('%d' % genfrkl.calculate_msg_length(spec))
    -- TODO: fixup constant gen




--------------------------------------------------------------------------------
-- 
-- remote routine prototypes
-- 
--------------------------------------------------------------------------------
@{
for field in spec.parsed_fields():
  if not genfrkl.is_primitive_kl_type(field.type):
    base_name = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)
    print "%%INCLUDE ros\lib%s.h" % base_name
}@




--------------------------------------------------------------------------------
-- 
-- local routine prototypes
-- 
--------------------------------------------------------------------------------
%INCLUDE ros\@(kl_libname).h




--------------------------------------------------------------------------------
-- 
-- Empty body
-- 
--------------------------------------------------------------------------------
BEGIN
END @(kl_libname)




ROUTINE @(kl_rpname)_len
BEGIN
@{
# 
# totale lengte is: sum(sizeof(field : fields))
#  - len primitives is bekend (need map to ktype_sz.t consts)
#  - len arrays: len(base_type) * array_len(field)
#  - len complex types: COMPLEX_TYPE_len(field)
# 
}
    RETURN (@(genfrkl.calculate_msg_length(spec)))
END @(kl_rpname)_len




ROUTINE @(kl_rpname)_name
BEGIN
    RETURN ('@(spec.short_name)')
END @(kl_rpname)_name




ROUTINE @(kl_rpname)_pid
BEGIN
    RETURN (RP@(msg_mapped_id_hex.upper())_ID)
END @(kl_rpname)_pid




ROUTINE @(kl_rpname)_ctor
BEGIN
    @(kl_rpname)_rset(this)
END @(kl_rpname)_ctor




ROUTINE @(kl_rpname)_rset
@[if genfrkl.has_arrays(spec)]@
VAR
    i__          : INTEGER -- TODO: only add vars if necessary
    array_len__  : INTEGER
@[end if]@
BEGIN
    -- reset each field to its default value
@{
for field in spec.parsed_fields():
  kl_type = genfrkl.msg_type_to_kl(spec.package, field.type)

  # primitives can be zero-ed using a simple statement
  if genfrkl.is_primitive_kl_type(field.type):
    kl_zero = genfrkl.msg_type_to_zero_value(spec.package, field.type)

    # can only reset arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR i__ = 1 TO array_len__ DO"
      print "        this.%s[i__] = %s" % (field.name, kl_zero)
      print "    ENDFOR"

    # otherwise primitive types can just be set to their 'zero value'
    else:
      kl_zero = genfrkl.msg_type_to_zero_value(spec.package, field.type)
      print "    this.%s = %s" % (field.name, kl_zero)

  # not a primitive: assume complex type has '_rset' routine defined somewhere
  else:
    print "    -- TODO: this needs properly generated %INCLUDE directives"

    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)

    # can only reset arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR i__ = 1 TO array_len__ DO"
      print "        %s_rset(this.%s[i__])" % (pfx, field.name)
      print "    ENDFOR"

    # otherwise just call external routine on field
    else:
      print "    %s_rset(this.%s)" % (pfx, field.name)
}@
END @(kl_rpname)_rset




ROUTINE @(kl_rpname)_read

VAR
    stat__       : INTEGER
    i__          : INTEGER
    array_len__  : INTEGER -- TODO: only add var if necessary
BEGIN
    -- deserialise entire struct, reading from 'fd'

    -- TODO: use minimum amount of READ statements (group primitive
    --       reads as much as possible)
@{
for field in spec.parsed_fields():
  kl_type = genfrkl.msg_type_to_kl(spec.package, field.type)

  # primitives can be deserialised using a simple statement
  if genfrkl.is_primitive_kl_type(field.type):

    # can only read arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR i__ = 1 TO array_len__ DO"
      print "        READ fd(this.%s[i__])" % field.name
      print "        stat__ = IO_STATUS(fd)"
      print "        IF (stat__ <> 0) THEN RETURN (-stat__); ENDIF"
      print "    ENDFOR"

    # 
    else:
      print "    READ fd(this.%s)" % field.name
      print "    stat__ = IO_STATUS(fd)"
      print "    IF (stat__ <> 0) THEN RETURN (-stat__); ENDIF"

  # not a primitive: assume complex type has '_read' routine defined somewhere
  else:
    print "    -- TODO: this needs properly generated %INCLUDE directives"

    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)

    # can only read arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR i__ = 1 TO array_len__ DO"
      print "        stat__ = %s_read(this.%s[i__], fd)" % (pfx, field.name)
      print "        IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
      print "    ENDFOR"

    # otherwise just call external routine on field
    else:
      print "    stat__ = %s_read(this.%s, fd)" % (pfx, field.name)
      print "    IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
}@
    RETURN (-ABS(stat__))
END @(kl_rpname)_read




ROUTINE @(kl_rpname)_sread
BEGIN
    -- TODO: implement swapping read
    RETURN (@(kl_rpname)_read(this, fd))
END @(kl_rpname)_sread




ROUTINE @(kl_rpname)_wrte
VAR
    stat__       : INTEGER
    i__          : INTEGER
    array_len__  : INTEGER -- TODO: only add var if necessary
BEGIN
    -- serialise entire struct, writing to 'fd'

    -- TODO: use minimum amount of WRITE statements (group primitive
    --       writes as much as possible)
@{
for field in spec.parsed_fields():
  kl_type = genfrkl.msg_type_to_kl(spec.package, field.type)

  # primitives can be serialised using a simple statement
  if genfrkl.is_primitive_kl_type(field.type):

    # can only write arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR i__ = 1 TO array_len__ DO"
      print "        WRITE fd(this.%s[i__], CR)" % field.name
      print "        stat__ = IO_STATUS(fd)"
      print "        IF (stat__ <> 0) THEN RETURN (-stat__); ENDIF"
      print "    ENDFOR"

    # 
    else:
      print "    WRITE fd(this.%s, CR)" % field.name
      print "    stat__ = IO_STATUS(fd)"
      print "    IF (stat__ <> 0) THEN RETURN (-stat__); ENDIF"

  # not a primitive: assume complex type has '_wrte' routine defined somewhere
  else:
    print "    -- TODO: this needs properly generated %INCLUDE directives"

    pfx = genfrkl.map_complex_type_to_routine_prefix(spec.package, field.type)

    # can only write arrays one field at a time
    if field.is_array:
      print "    array_len__ = ARRAY_LEN(this.%s)" % field.name
      print "    FOR i__ = 1 TO array_len__ DO"
      print "        stat__ = %s_wrte(this.%s[i__], fd)" % (pfx, field.name)
      print "        IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
      print "    ENDFOR"

    # otherwise just call external routine on field
    else:
      print "    stat__ = %s_wrte(this.%s, fd)" % (pfx, field.name)
      print "    IF (stat__ <> 0) THEN RETURN (-ABS(stat__)); ENDIF"
}@
    RETURN (-ABS(stat__))
END @(kl_rpname)_wrte




ROUTINE @(kl_rpname)_swrte
BEGIN
    -- TODO: implement swapping write
    RETURN (@(kl_rpname)_wrte(this, fd))
END @(kl_rpname)_swrte




ROUTINE @(kl_rpname)_tstr
--VAR
--    seq_str__    : STRING[10]
BEGIN
    -- returns: joint_position(hdr(..), ..)
    -- TODO: possibly make use of int2str() routine
    -- TODO: perhaps use @file_name_in or @spec.short_name?

    --CNV_INT_STR(this.seq, 1, 10, seq_str__)
    RETURN ('@(spec.short_name)(' &
        + rp_hdr_tstr(this.hdr) + ',' &
        + ')')
--        + seq_str__ &
END @(kl_rpname)_tstr




ROUTINE @(kl_rpname)_dump
VAR
    stat__       : INTEGER
BEGIN
    WRITE fd(@(kl_rpname)_tstr(this), CR)
    stat__ = IO_STATUS(fd)
    RETURN (-ABS(stat__))
END @(kl_rpname)_dump
